import { createElement, createRef, Component } from 'react';
import { DraggableCore } from 'react-draggable';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function isDataURL(url) {
  if (url === null) {
    return false;
  }

  var regex = /^\s*data:([a-z]+\/[a-z]+(;[a-z-]+=[a-z-]+)?)?(;base64)?,[a-z0-9!$&',()*+;=\-._~:@/?%\s]*\s*$/i;
  return !!url.match(regex);
}

function loadImageURL(imageURL, crossOrigin) {
  if (crossOrigin === void 0) {
    crossOrigin = '';
  }

  return new Promise(function (resolve, reject) {
    var image = new Image();

    image.onload = function () {
      return resolve(image);
    };

    image.onerror = reject;

    if (isDataURL(imageURL) === false && crossOrigin) {
      image.crossOrigin = crossOrigin;
    }

    image.src = imageURL;
  });
}

/* eslint-env browser, node */
function loadImageFile(imageFile) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function (e) {
      try {
        if (!e.target) {
          reject('No target');
        } else {
          var image = loadImageURL(e.target.result);
          resolve(image);
        }
      } catch (e) {
        reject(e);
      }
    };

    reader.readAsDataURL(imageFile);
  });
}

// helpers to calculate vectors
var toRadians = function toRadians(degree) {
  return degree * (Math.PI / 180);
};

var isFileAPISupported = typeof File !== 'undefined';
var defaultPixelRatio = typeof window !== 'undefined' && window.devicePixelRatio ? window.devicePixelRatio : 1; // Draws a rounded rectangle on a 2D context.

var drawRoundedRect = function drawRoundedRect(context, x, y, width, height, borderRadius) {
  if (borderRadius === 0) {
    context.rect(x, y, width, height);
  } else {
    var widthMinusRad = width - borderRadius;
    var heightMinusRad = height - borderRadius;
    context.translate(x, y);
    context.arc(borderRadius, borderRadius, borderRadius, Math.PI, Math.PI * 1.5);
    context.lineTo(widthMinusRad, 0);
    context.arc(widthMinusRad, borderRadius, borderRadius, Math.PI * 1.5, Math.PI * 2);
    context.lineTo(width, heightMinusRad);
    context.arc(widthMinusRad, heightMinusRad, borderRadius, Math.PI * 2, Math.PI * 0.5);
    context.lineTo(borderRadius, height);
    context.arc(borderRadius, heightMinusRad, borderRadius, Math.PI * 0.5, Math.PI);
    context.translate(-x, -y);
  }
};

var defaultEmptyImage = {
  x: 0.5,
  y: 0.5,
  width: 0,
  height: 0
};
var defaultProps = {
  scale: 1,
  rotate: 0,
  border: 25,
  borderRadius: 0,
  width: 200,
  height: 200,
  color: [0, 0, 0, 0.5],
  disableBoundaryChecks: false,
  disableHiDPIScaling: false
};

var AvatarEditor =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(AvatarEditor, _React$Component);

  function AvatarEditor(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.pixelRatio = defaultPixelRatio;

    _this.clearImage = function () {
      var canvas = _this.getCanvas();

      var context = _this.getContext();

      context.clearRect(0, 0, canvas.width, canvas.height);

      _this.setState({
        image: defaultEmptyImage
      });
    };

    _this.handleDrag = function (_, data) {
      var deltaX = data.deltaX,
          deltaY = data.deltaY;
      var _this$props = _this.props,
          rotate = _this$props.rotate,
          scale = _this$props.scale,
          onPositionChange = _this$props.onPositionChange;
      var image = _this.state.image;
      var nextRotate = rotate % 360 < 0 ? rotate + 360 : rotate % 360;
      var width = image.width * scale;
      var height = image.height * scale;

      var _this$getCroppingRect = _this.getCroppingRect(),
          lastX = _this$getCroppingRect.x,
          lastY = _this$getCroppingRect.y;

      var cos = Math.cos(toRadians(nextRotate));
      var sin = Math.sin(toRadians(nextRotate));
      var x = lastX * width + -deltaX * cos + deltaY * sin;
      var y = lastY * height + deltaX * sin + -deltaY * cos;

      var relativeWidth = 1 / scale * _this.getXScale();

      var relativeHeight = 1 / scale * _this.getYScale();

      var position = {
        x: x / width + relativeWidth / 2,
        y: y / height + relativeHeight / 2
      };
      onPositionChange && onPositionChange(position);

      _this.setState({
        image: _extends({}, _this.state.image, {}, position)
      });
    };

    _this.handleStartDrag = function () {
      return _this.setState({
        dragging: true
      });
    };

    _this.handleStopDrag = function () {
      return _this.setState({
        dragging: false
      });
    };

    _this.state = {
      dragging: false,
      image: defaultEmptyImage
    };
    _this.canvas = createRef();
    _this.pixelRatio = props.disableHiDPIScaling ? 1 : defaultPixelRatio;
    return _this;
  }

  var _proto = AvatarEditor.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.loadImage();
    var context = this.getContext();
    this.paint(context);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (this.props.image && this.props.image !== prevProps.image || this.props.width !== prevProps.width || this.props.height !== prevProps.height) {
      this.loadImage();
    } else if (!this.props.image) {
      this.clearImage();
    }

    var canvas = this.getCanvas();
    var context = this.getContext();
    context.clearRect(0, 0, canvas.width, canvas.height);
    this.paint(context);
    this.paintImage(context, this.state.image, this.props.border);

    if (prevProps.image !== this.props.image || prevProps.width !== this.props.width || prevProps.height !== this.props.height || prevProps.position !== this.props.position || prevProps.scale !== this.props.scale || prevProps.rotate !== this.props.rotate || prevState.image.x !== this.state.image.x || prevState.image.y !== this.state.image.y) {
      this.props.onImageChange && this.props.onImageChange();
    }
  };

  _proto.getCanvas = function getCanvas() {
    if (!this.canvas.current) {
      throw new Error('No canvas found, please report this to: https://github.com/mosch/react-avatar-editor/issues');
    }

    return this.canvas.current;
  };

  _proto.getContext = function getContext() {
    var context = this.getCanvas().getContext('2d');

    if (!context) {
      throw new Error(' No context found, please report this to: https://github.com/mosch/react-avatar-editor/issues');
    }

    return context;
  };

  _proto.isVertical = function isVertical() {
    return this.props.rotate % 180 !== 0;
  };

  _proto.getBorders = function getBorders(border) {
    return Array.isArray(border) ? border : [border, border];
  };

  _proto.getDimensions = function getDimensions() {
    var _this$props2 = this.props,
        width = _this$props2.width,
        height = _this$props2.height,
        rotate = _this$props2.rotate,
        border = _this$props2.border;

    var _this$getBorders = this.getBorders(border),
        borderX = _this$getBorders[0],
        borderY = _this$getBorders[1];

    var canvas = this.isVertical() ? {
      width: height + borderX * 2,
      height: width + borderY * 2
    } : {
      width: width + borderX * 2,
      height: height + borderY * 2
    };
    return {
      canvas: canvas,
      rotate: rotate,
      width: width,
      height: height,
      border: border
    };
  };

  _proto.getImage = function getImage() {
    // get relative coordinates (0 to 1)
    var cropRect = this.getCroppingRect();
    var image = this.state.image; // create a canvas with the correct dimensions

    var canvas = document.createElement('canvas');

    if (image.resource) {
      // get actual pixel coordinates
      var actualCropRect = _extends({}, cropRect, {
        x: cropRect.x * image.resource.width,
        y: cropRect.y * image.resource.height,
        width: cropRect.width * image.resource.width,
        height: cropRect.height * image.resource.height
      });

      if (this.isVertical()) {
        canvas.width = actualCropRect.height;
        canvas.height = actualCropRect.width;
      } else {
        canvas.width = actualCropRect.width;
        canvas.height = actualCropRect.height;
      } // draw the full-size image at the correct position,
      // the image gets truncated to the size of the canvas.


      var context = canvas.getContext('2d');

      if (context) {
        context.translate(canvas.width / 2, canvas.height / 2);
        context.rotate(this.props.rotate * Math.PI / 180);
        context.translate(-(canvas.width / 2), -(canvas.height / 2));

        if (this.isVertical()) {
          context.translate((canvas.width - canvas.height) / 2, (canvas.height - canvas.width) / 2);
        }

        context.drawImage(image.resource, -cropRect.x, -cropRect.y);
      }
    }

    return canvas;
  }
  /**
   * Get the image scaled to original canvas size.
   * This was default in 4.x and is now kept as a legacy method.
   */
  ;

  _proto.getImageScaledToCanvas = function getImageScaledToCanvas() {
    var _this$getDimensions = this.getDimensions(),
        width = _this$getDimensions.width,
        height = _this$getDimensions.height;

    var canvas = document.createElement('canvas');

    if (this.isVertical()) {
      canvas.width = height;
      canvas.height = width;
    } else {
      canvas.width = width;
      canvas.height = height;
    }

    var context = canvas.getContext('2d');

    if (context) {
      // don't paint a border here, as it is the resulting image
      this.paintImage(context, this.state.image, 0, 1);
    }

    return canvas;
  };

  _proto.getXScale = function getXScale() {
    var canvasAspect = this.props.width / this.props.height;
    var imageAspect = this.state.image.width / this.state.image.height;
    return Math.min(1, canvasAspect / imageAspect);
  };

  _proto.getYScale = function getYScale() {
    var canvasAspect = this.props.height / this.props.width;
    var imageAspect = this.state.image.height / this.state.image.width;
    return Math.min(1, canvasAspect / imageAspect);
  };

  _proto.getCroppingRect = function getCroppingRect() {
    var position = this.props.position || {
      x: this.state.image.x,
      y: this.state.image.y
    };
    var width = 1 / this.props.scale * this.getXScale();
    var height = 1 / this.props.scale * this.getYScale();
    var croppingRect = {
      x: position.x - width / 2,
      y: position.y - height / 2,
      width: width,
      height: height
    };
    var xMin = 0;
    var xMax = 1 - croppingRect.width;
    var yMin = 0;
    var yMax = 1 - croppingRect.height; // If the cropping rect is larger than the image, then we need to change
    // our maxima & minima for x & y to allow the image to appear anywhere up
    // to the very edge of the cropping rect.

    var isLargerThanImage = this.props.disableBoundaryChecks || width > 1 || height > 1;

    if (isLargerThanImage) {
      xMin = -croppingRect.width;
      xMax = 1;
      yMin = -croppingRect.height;
      yMax = 1;
    }

    return _extends({}, croppingRect, {
      x: Math.max(xMin, Math.min(croppingRect.x, xMax)),
      y: Math.max(yMin, Math.min(croppingRect.y, yMax))
    });
  };

  _proto.loadImage = function loadImage() {
    var _this2 = this;

    var _this$props3 = this.props,
        image = _this$props3.image,
        onLoadFailure = _this$props3.onLoadFailure,
        onImageReady = _this$props3.onImageReady,
        onLoadSuccess = _this$props3.onLoadSuccess,
        crossOrigin = _this$props3.crossOrigin;

    var handleImageReady = function handleImageReady(image) {
      var imageState = _extends({}, _this2.getInitialSize(image.width, image.height), {
        resource: image,
        x: 0.5,
        y: 0.5
      });

      _this2.setState({
        image: imageState
      }, onImageReady);

      onLoadSuccess && onLoadSuccess(imageState);
    };

    if (isFileAPISupported && image instanceof File) {
      loadImageFile(image).then(handleImageReady)["catch"](onLoadFailure);
    } else if (typeof image === 'string') {
      loadImageURL(image, crossOrigin).then(handleImageReady)["catch"](onLoadFailure);
    }
  };

  _proto.getInitialSize = function getInitialSize(width, height) {
    var dimensions = this.getDimensions();
    var canvasRatio = dimensions.height / dimensions.width;
    var imageRatio = height / width;

    if (canvasRatio > imageRatio) {
      return {
        height: dimensions.height,
        width: width * (dimensions.height / height)
      };
    } else {
      return {
        width: dimensions.width,
        height: height * (dimensions.width / width)
      };
    }
  };

  _proto.paintImage = function paintImage(context, image, border, scaleFactor) {
    if (scaleFactor === void 0) {
      scaleFactor = defaultPixelRatio;
    }

    if (image.resource) {
      var position = this.calculatePosition(image, border);

      var _this$getCroppingRect2 = this.getCroppingRect(),
          x = _this$getCroppingRect2.x,
          y = _this$getCroppingRect2.y;

      context.fillStyle = 'red';
      context.fillRect(x, y, 3, 3);
      context.save();
      context.translate(context.canvas.width / 2, context.canvas.height / 2);
      context.rotate(this.props.rotate * Math.PI / 180);
      context.translate(-(context.canvas.width / 2), -(context.canvas.height / 2));

      if (this.isVertical()) {
        context.translate((context.canvas.width - context.canvas.height) / 2, (context.canvas.height - context.canvas.width) / 2);
      }

      context.scale(scaleFactor, scaleFactor);
      context.globalCompositeOperation = 'destination-over';
      context.drawImage(image.resource, position.x, position.y, position.width, position.height);
      context.restore();
    }
  };

  _proto.calculatePosition = function calculatePosition(image, border) {
    var _this$getBorders2 = this.getBorders(border),
        borderX = _this$getBorders2[0],
        borderY = _this$getBorders2[1];

    var croppingRect = this.getCroppingRect();
    var width = image.width * this.props.scale;
    var height = image.height * this.props.scale;
    var x = -croppingRect.x * width;
    var y = -croppingRect.y * height;

    if (this.isVertical()) {
      x += borderY;
      y += borderX;
    } else {
      x += borderX;
      y += borderY;
    }

    return {
      x: x,
      y: y,
      height: height,
      width: width
    };
  };

  _proto.paint = function paint(context) {
    context.save();
    context.scale(this.pixelRatio, this.pixelRatio);
    context.translate(0, 0);
    context.fillStyle = 'rgba(' + this.props.color.slice(0, 4).join(',') + ')';
    var borderRadius = this.props.borderRadius;
    var dimensions = this.getDimensions();

    var _this$getBorders3 = this.getBorders(dimensions.border),
        borderSizeX = _this$getBorders3[0],
        borderSizeY = _this$getBorders3[1];

    var height = dimensions.canvas.height;
    var width = dimensions.canvas.width; // clamp border radius between zero (perfect rectangle) and half the size without borders (perfect circle or "pill")

    borderRadius = Math.max(borderRadius, 0);
    borderRadius = Math.min(borderRadius, width / 2 - borderSizeX, height / 2 - borderSizeY);
    context.beginPath(); // inner rect, possibly rounded

    drawRoundedRect(context, borderSizeX, borderSizeY, width - borderSizeX * 2, height - borderSizeY * 2, borderRadius);
    context.rect(width, 0, -width, height); // outer rect, drawn "counterclockwise"

    context.fill('evenodd');
    context.restore();
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        scale = _this$props4.scale,
        rotate = _this$props4.rotate,
        image = _this$props4.image,
        border = _this$props4.border,
        borderRadius = _this$props4.borderRadius,
        width = _this$props4.width,
        height = _this$props4.height,
        position = _this$props4.position,
        color = _this$props4.color,
        style = _this$props4.style,
        crossOrigin = _this$props4.crossOrigin,
        onLoadFailure = _this$props4.onLoadFailure,
        onLoadSuccess = _this$props4.onLoadSuccess,
        onImageReady = _this$props4.onImageReady,
        onImageChange = _this$props4.onImageChange,
        onMouseUp = _this$props4.onMouseUp,
        onMouseMove = _this$props4.onMouseMove,
        onPositionChange = _this$props4.onPositionChange,
        disableBoundaryChecks = _this$props4.disableBoundaryChecks,
        disableHiDPIScaling = _this$props4.disableHiDPIScaling,
        rest = _objectWithoutPropertiesLoose(_this$props4, ["scale", "rotate", "image", "border", "borderRadius", "width", "height", "position", "color", "style", "crossOrigin", "onLoadFailure", "onLoadSuccess", "onImageReady", "onImageChange", "onMouseUp", "onMouseMove", "onPositionChange", "disableBoundaryChecks", "disableHiDPIScaling"]);

    var dimensions = this.getDimensions();
    var defaultStyle = {
      width: dimensions.canvas.width,
      height: dimensions.canvas.height,
      cursor: this.state.dragging ? 'grabbing' : 'grab',
      touchAction: 'none'
    };
    var attributes = {
      width: dimensions.canvas.width * this.pixelRatio,
      height: dimensions.canvas.height * this.pixelRatio,
      style: _extends({}, defaultStyle, {}, style)
    };
    return createElement(DraggableCore, {
      onStart: this.handleStartDrag,
      onStop: this.handleStopDrag,
      onDrag: this.handleDrag
    }, createElement("canvas", Object.assign({
      ref: this.canvas
    }, attributes, rest)));
  };

  return AvatarEditor;
}(Component);

AvatarEditor.defaultProps = defaultProps;

export default AvatarEditor;
//# sourceMappingURL=react-avatar-editor.esm.js.map
