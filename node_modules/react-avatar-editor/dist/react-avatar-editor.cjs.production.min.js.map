{"version":3,"file":"react-avatar-editor.cjs.production.min.js","sources":["../src/utils/load-image-url.ts","../src/utils/to-radians.ts","../src/index.tsx","../src/utils/load-image-file.ts"],"sourcesContent":["function isDataURL(url: string) {\n  if (url === null) {\n    return false\n  }\n  const regex = /^\\s*data:([a-z]+\\/[a-z]+(;[a-z-]+=[a-z-]+)?)?(;base64)?,[a-z0-9!$&',()*+;=\\-._~:@/?%\\s]*\\s*$/i\n  return !!url.match(regex)\n}\n\nexport default function loadImageURL(\n  imageURL: string,\n  crossOrigin = ''\n): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const image = new Image()\n    image.onload = () => resolve(image)\n    image.onerror = reject\n    if (isDataURL(imageURL) === false && crossOrigin) {\n      image.crossOrigin = crossOrigin\n    }\n    image.src = imageURL\n  })\n}\n","// helpers to calculate vectors\nconst toRadians = (degree: number) => degree * (Math.PI / 180)\nexport default toRadians\n","import * as React from 'react'\nimport loadImageURL from './utils/load-image-url'\nimport loadImageFile from './utils/load-image-file'\nimport toRadians from './utils/to-radians'\nimport { DraggableCore, DraggableEvent, DraggableData } from 'react-draggable'\n\ntype BorderType = [number, number] | number\n\ninterface IAvatarEditorProps {\n  style?: any\n  image?: string | File\n  width: number\n  border?: BorderType\n  height: number\n  position?: IPosition\n  crossOrigin?: '' | 'anonymous' | 'use-credentials'\n  onLoadFailure?: () => void\n  onLoadSuccess?: (image: IImageState) => void\n  onImageReady?: () => void\n  onImageChange?: () => void\n  onMouseUp?: () => void\n  onMouseMove?: (e: React.TouchEvent | React.MouseEvent) => void\n  onPositionChange?: (position: IPosition) => void\n}\n\ninterface IPosition {\n  x: number\n  y: number\n}\n\ninterface IImageState {\n  x: number\n  y: number\n  width: number\n  height: number\n  resource?: HTMLImageElement\n}\n\ninterface IAvatarEditorState {\n  dragging: boolean\n  image: IImageState\n}\n\nconst isFileAPISupported = typeof File !== 'undefined'\nconst defaultPixelRatio =\n  typeof window !== 'undefined' && window.devicePixelRatio\n    ? window.devicePixelRatio\n    : 1\n\n// Draws a rounded rectangle on a 2D context.\nconst drawRoundedRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  borderRadius: number\n) => {\n  if (borderRadius === 0) {\n    context.rect(x, y, width, height)\n  } else {\n    const widthMinusRad = width - borderRadius\n    const heightMinusRad = height - borderRadius\n    context.translate(x, y)\n    context.arc(\n      borderRadius,\n      borderRadius,\n      borderRadius,\n      Math.PI,\n      Math.PI * 1.5\n    )\n    context.lineTo(widthMinusRad, 0)\n    context.arc(\n      widthMinusRad,\n      borderRadius,\n      borderRadius,\n      Math.PI * 1.5,\n      Math.PI * 2\n    )\n    context.lineTo(width, heightMinusRad)\n    context.arc(\n      widthMinusRad,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 2,\n      Math.PI * 0.5\n    )\n    context.lineTo(borderRadius, height)\n    context.arc(\n      borderRadius,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 0.5,\n      Math.PI\n    )\n    context.translate(-x, -y)\n  }\n}\n\nconst defaultEmptyImage = {\n  x: 0.5,\n  y: 0.5,\n  width: 0,\n  height: 0,\n}\n\nconst defaultProps = {\n  scale: 1,\n  rotate: 0,\n  border: 25,\n  borderRadius: 0,\n  width: 200,\n  height: 200,\n  color: [0, 0, 0, 0.5],\n  disableBoundaryChecks: false,\n  disableHiDPIScaling: false,\n}\n\ntype DefaultProps = Readonly<typeof defaultProps>\ntype IAllAvatarEditorProps = IAvatarEditorProps & DefaultProps\n\nclass AvatarEditor extends React.Component<\n  IAllAvatarEditorProps,\n  IAvatarEditorState\n> {\n  static defaultProps = defaultProps\n  private canvas: React.RefObject<HTMLCanvasElement>\n  private pixelRatio = defaultPixelRatio\n\n  constructor(props: IAllAvatarEditorProps) {\n    super(props)\n    this.state = {\n      dragging: false,\n      image: defaultEmptyImage,\n    }\n    this.canvas = React.createRef()\n    this.pixelRatio = props.disableHiDPIScaling ? 1 : defaultPixelRatio\n  }\n\n  componentDidMount() {\n    this.loadImage()\n    const context = this.getContext()\n    this.paint(context)\n  }\n\n  componentDidUpdate(\n    prevProps: IAllAvatarEditorProps,\n    prevState: IAvatarEditorState\n  ) {\n    if (\n      (this.props.image && this.props.image !== prevProps.image) ||\n      this.props.width !== prevProps.width ||\n      this.props.height !== prevProps.height\n    ) {\n      this.loadImage()\n    } else if (!this.props.image) {\n      this.clearImage()\n    }\n\n    const canvas = this.getCanvas()\n    const context = this.getContext()\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    this.paint(context)\n    this.paintImage(context, this.state.image, this.props.border)\n\n    if (\n      prevProps.image !== this.props.image ||\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      prevProps.position !== this.props.position ||\n      prevProps.scale !== this.props.scale ||\n      prevProps.rotate !== this.props.rotate ||\n      prevState.image.x !== this.state.image.x ||\n      prevState.image.y !== this.state.image.y\n    ) {\n      this.props.onImageChange && this.props.onImageChange()\n    }\n  }\n\n  private getCanvas(): HTMLCanvasElement {\n    if (!this.canvas.current) {\n      throw new Error(\n        'No canvas found, please report this to: https://github.com/mosch/react-avatar-editor/issues'\n      )\n    }\n\n    return this.canvas.current\n  }\n\n  private getContext() {\n    const context = this.getCanvas().getContext('2d')\n    if (!context) {\n      throw new Error(\n        ' No context found, please report this to: https://github.com/mosch/react-avatar-editor/issues'\n      )\n    }\n\n    return context\n  }\n\n  private isVertical() {\n    return this.props.rotate % 180 !== 0\n  }\n\n  private getBorders(border: BorderType) {\n    return Array.isArray(border) ? border : [border, border]\n  }\n\n  private getDimensions() {\n    const { width, height, rotate, border } = this.props\n    const [borderX, borderY] = this.getBorders(border)\n    const canvas = this.isVertical()\n      ? { width: height + borderX * 2, height: width + borderY * 2 }\n      : {\n          width: width + borderX * 2,\n          height: height + borderY * 2,\n        }\n\n    return {\n      canvas,\n      rotate,\n      width,\n      height,\n      border,\n    }\n  }\n\n  getImage() {\n    // get relative coordinates (0 to 1)\n    const cropRect = this.getCroppingRect()\n    const image = this.state.image\n\n    // create a canvas with the correct dimensions\n    const canvas = document.createElement('canvas')\n\n    if (image.resource) {\n      // get actual pixel coordinates\n      const actualCropRect = {\n        ...cropRect,\n        x: cropRect.x * image.resource.width,\n        y: cropRect.y * image.resource.height,\n        width: cropRect.width * image.resource.width,\n        height: cropRect.height * image.resource.height,\n      }\n\n      if (this.isVertical()) {\n        canvas.width = actualCropRect.height\n        canvas.height = actualCropRect.width\n      } else {\n        canvas.width = actualCropRect.width\n        canvas.height = actualCropRect.height\n      }\n\n      // draw the full-size image at the correct position,\n      // the image gets truncated to the size of the canvas.\n      const context = canvas.getContext('2d')\n      if (context) {\n        context.translate(canvas.width / 2, canvas.height / 2)\n        context.rotate((this.props.rotate * Math.PI) / 180)\n        context.translate(-(canvas.width / 2), -(canvas.height / 2))\n\n        if (this.isVertical()) {\n          context.translate(\n            (canvas.width - canvas.height) / 2,\n            (canvas.height - canvas.width) / 2\n          )\n        }\n\n        context.drawImage(image.resource, -cropRect.x, -cropRect.y)\n      }\n    }\n\n    return canvas\n  }\n\n  /**\n   * Get the image scaled to original canvas size.\n   * This was default in 4.x and is now kept as a legacy method.\n   */\n  getImageScaledToCanvas() {\n    const { width, height } = this.getDimensions()\n\n    const canvas = document.createElement('canvas')\n\n    if (this.isVertical()) {\n      canvas.width = height\n      canvas.height = width\n    } else {\n      canvas.width = width\n      canvas.height = height\n    }\n\n    const context = canvas.getContext('2d')\n    if (context) {\n      // don't paint a border here, as it is the resulting image\n      this.paintImage(context, this.state.image, 0, 1)\n    }\n\n    return canvas\n  }\n\n  private getXScale() {\n    const canvasAspect = this.props.width / this.props.height\n    const imageAspect = this.state.image.width / this.state.image.height\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  private getYScale() {\n    const canvasAspect = this.props.height / this.props.width\n    const imageAspect = this.state.image.height / this.state.image.width\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  getCroppingRect() {\n    const position = this.props.position || {\n      x: this.state.image.x,\n      y: this.state.image.y,\n    }\n    const width = (1 / this.props.scale) * this.getXScale()\n    const height = (1 / this.props.scale) * this.getYScale()\n\n    const croppingRect = {\n      x: position.x - width / 2,\n      y: position.y - height / 2,\n      width,\n      height,\n    }\n\n    let xMin = 0\n    let xMax = 1 - croppingRect.width\n    let yMin = 0\n    let yMax = 1 - croppingRect.height\n\n    // If the cropping rect is larger than the image, then we need to change\n    // our maxima & minima for x & y to allow the image to appear anywhere up\n    // to the very edge of the cropping rect.\n    const isLargerThanImage =\n      this.props.disableBoundaryChecks || width > 1 || height > 1\n\n    if (isLargerThanImage) {\n      xMin = -croppingRect.width\n      xMax = 1\n      yMin = -croppingRect.height\n      yMax = 1\n    }\n\n    return {\n      ...croppingRect,\n      x: Math.max(xMin, Math.min(croppingRect.x, xMax)),\n      y: Math.max(yMin, Math.min(croppingRect.y, yMax)),\n    }\n  }\n\n  private loadImage() {\n    const {\n      image,\n      onLoadFailure,\n      onImageReady,\n      onLoadSuccess,\n      crossOrigin,\n    } = this.props\n\n    const handleImageReady = (image: HTMLImageElement) => {\n      const imageState = {\n        ...this.getInitialSize(image.width, image.height),\n        resource: image,\n        x: 0.5,\n        y: 0.5,\n      }\n\n      this.setState({ image: imageState }, onImageReady)\n      onLoadSuccess && onLoadSuccess(imageState)\n    }\n\n    if (isFileAPISupported && image instanceof File) {\n      loadImageFile(image)\n        .then(handleImageReady)\n        .catch(onLoadFailure)\n    } else if (typeof image === 'string') {\n      loadImageURL(image, crossOrigin)\n        .then(handleImageReady)\n        .catch(onLoadFailure)\n    }\n  }\n\n  private getInitialSize(width: number, height: number) {\n    const dimensions = this.getDimensions()\n    const canvasRatio = dimensions.height / dimensions.width\n    const imageRatio = height / width\n\n    if (canvasRatio > imageRatio) {\n      return {\n        height: dimensions.height,\n        width: width * (dimensions.height / height),\n      }\n    } else {\n      return {\n        width: dimensions.width,\n        height: height * (dimensions.width / width),\n      }\n    }\n  }\n\n  private clearImage = () => {\n    const canvas = this.getCanvas()\n    const context = this.getContext()\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    this.setState({\n      image: defaultEmptyImage,\n    })\n  }\n\n  private paintImage(\n    context: CanvasRenderingContext2D,\n    image: IImageState,\n    border: BorderType,\n    scaleFactor = defaultPixelRatio\n  ) {\n    if (image.resource) {\n      const position = this.calculatePosition(image, border)\n      const { x, y } = this.getCroppingRect()\n\n      context.fillStyle = 'red'\n      context.fillRect(x, y, 3, 3)\n\n      context.save()\n\n      context.translate(context.canvas.width / 2, context.canvas.height / 2)\n      context.rotate((this.props.rotate * Math.PI) / 180)\n      context.translate(\n        -(context.canvas.width / 2),\n        -(context.canvas.height / 2)\n      )\n\n      if (this.isVertical()) {\n        context.translate(\n          (context.canvas.width - context.canvas.height) / 2,\n          (context.canvas.height - context.canvas.width) / 2\n        )\n      }\n\n      context.scale(scaleFactor, scaleFactor)\n\n      context.globalCompositeOperation = 'destination-over'\n      context.drawImage(\n        image.resource,\n        position.x,\n        position.y,\n        position.width,\n        position.height\n      )\n\n      context.restore()\n    }\n  }\n\n  private calculatePosition(image: IImageState, border: BorderType) {\n    const [borderX, borderY] = this.getBorders(border)\n\n    const croppingRect = this.getCroppingRect()\n\n    const width = image.width * this.props.scale\n    const height = image.height * this.props.scale\n\n    let x = -croppingRect.x * width\n    let y = -croppingRect.y * height\n\n    if (this.isVertical()) {\n      x += borderY\n      y += borderX\n    } else {\n      x += borderX\n      y += borderY\n    }\n\n    return {\n      x,\n      y,\n      height,\n      width,\n    }\n  }\n\n  private paint(context: CanvasRenderingContext2D) {\n    context.save()\n    context.scale(this.pixelRatio, this.pixelRatio)\n    context.translate(0, 0)\n    context.fillStyle = 'rgba(' + this.props.color.slice(0, 4).join(',') + ')'\n\n    let borderRadius = this.props.borderRadius\n    const dimensions = this.getDimensions()\n    const [borderSizeX, borderSizeY] = this.getBorders(dimensions.border)\n    const height = dimensions.canvas.height\n    const width = dimensions.canvas.width\n\n    // clamp border radius between zero (perfect rectangle) and half the size without borders (perfect circle or \"pill\")\n    borderRadius = Math.max(borderRadius, 0)\n    borderRadius = Math.min(\n      borderRadius,\n      width / 2 - borderSizeX,\n      height / 2 - borderSizeY\n    )\n\n    context.beginPath()\n    // inner rect, possibly rounded\n    drawRoundedRect(\n      context,\n      borderSizeX,\n      borderSizeY,\n      width - borderSizeX * 2,\n      height - borderSizeY * 2,\n      borderRadius\n    )\n    context.rect(width, 0, -width, height) // outer rect, drawn \"counterclockwise\"\n    context.fill('evenodd')\n\n    context.restore()\n  }\n\n  private handleDrag = (_: DraggableEvent, data: DraggableData) => {\n    const { deltaX, deltaY } = data\n    const { rotate, scale, onPositionChange } = this.props\n    const { image } = this.state\n\n    const nextRotate = rotate % 360 < 0 ? rotate + 360 : rotate % 360\n    const width = image.width * scale\n    const height = image.height * scale\n\n    const { x: lastX, y: lastY } = this.getCroppingRect()\n\n    const cos = Math.cos(toRadians(nextRotate))\n    const sin = Math.sin(toRadians(nextRotate))\n\n    const x = lastX * width + -deltaX * cos + deltaY * sin\n    const y = lastY * height + deltaX * sin + -deltaY * cos\n\n    const relativeWidth = (1 / scale) * this.getXScale()\n    const relativeHeight = (1 / scale) * this.getYScale()\n\n    const position = {\n      x: x / width + relativeWidth / 2,\n      y: y / height + relativeHeight / 2,\n    }\n\n    onPositionChange && onPositionChange(position)\n\n    this.setState({\n      image: {\n        ...this.state.image,\n        ...position,\n      },\n    })\n  }\n\n  private handleStartDrag = () => this.setState({ dragging: true })\n  private handleStopDrag = () => this.setState({ dragging: false })\n\n  render() {\n    const {\n      scale,\n      rotate,\n      image,\n      border,\n      borderRadius,\n      width,\n      height,\n      position,\n      color,\n      style,\n      crossOrigin,\n      onLoadFailure,\n      onLoadSuccess,\n      onImageReady,\n      onImageChange,\n      onMouseUp,\n      onMouseMove,\n      onPositionChange,\n      disableBoundaryChecks,\n      disableHiDPIScaling,\n      ...rest\n    } = this.props\n\n    const dimensions = this.getDimensions()\n    const defaultStyle = {\n      width: dimensions.canvas.width,\n      height: dimensions.canvas.height,\n      cursor: this.state.dragging ? 'grabbing' : 'grab',\n      touchAction: 'none',\n    }\n\n    const attributes = {\n      width: dimensions.canvas.width * this.pixelRatio,\n      height: dimensions.canvas.height * this.pixelRatio,\n      style: {\n        ...defaultStyle,\n        ...style,\n      },\n    }\n\n    return (\n      <DraggableCore\n        onStart={this.handleStartDrag}\n        onStop={this.handleStopDrag}\n        onDrag={this.handleDrag}\n      >\n        <canvas ref={this.canvas} {...attributes} {...rest} />\n      </DraggableCore>\n    )\n  }\n}\n\nexport default AvatarEditor\n","/* eslint-env browser, node */\nimport loadImageURL from './load-image-url'\n\nexport default function loadImageFile(\n  imageFile: File\n): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = e => {\n      try {\n        if (!e.target) {\n          reject('No target')\n        } else {\n          const image = loadImageURL(e.target.result as string)\n          resolve(image)\n        }\n      } catch (e) {\n        reject(e)\n      }\n    }\n    reader.readAsDataURL(imageFile)\n  })\n}\n"],"names":["loadImageURL","imageURL","crossOrigin","Promise","resolve","reject","url","image","Image","onload","onerror","match","src","toRadians","degree","Math","PI","isFileAPISupported","File","defaultPixelRatio","window","devicePixelRatio","defaultEmptyImage","x","y","width","height","AvatarEditor","props","pixelRatio","clearImage","canvas","_this","getCanvas","getContext","clearRect","setState","handleDrag","_","data","deltaX","deltaY","rotate","scale","onPositionChange","state","nextRotate","getCroppingRect","lastX","lastY","cos","sin","position","getXScale","getYScale","handleStartDrag","dragging","handleStopDrag","React","disableHiDPIScaling","componentDidMount","loadImage","context","this","paint","componentDidUpdate","prevProps","prevState","paintImage","border","onImageChange","current","Error","isVertical","getBorders","Array","isArray","getDimensions","borderX","borderY","getImage","cropRect","document","createElement","resource","actualCropRect","translate","drawImage","getImageScaledToCanvas","min","croppingRect","xMin","xMax","yMin","yMax","disableBoundaryChecks","max","imageFile","onLoadFailure","onImageReady","onLoadSuccess","handleImageReady","imageState","_this2","getInitialSize","reader","FileReader","e","target","result","readAsDataURL","then","dimensions","scaleFactor","calculatePosition","fillStyle","fillRect","save","globalCompositeOperation","restore","color","slice","join","borderRadius","borderSizeX","borderSizeY","beginPath","rect","widthMinusRad","heightMinusRad","arc","lineTo","drawRoundedRect","fill","render","style","rest","attributes","cursor","touchAction","DraggableCore","onStart","onStop","onDrag","Object","assign","ref","defaultProps"],"mappings":"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"}