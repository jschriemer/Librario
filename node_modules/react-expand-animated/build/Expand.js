'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GROUP, _PropTypes$shape;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// In firefox, setTimeout with duration 0 too short for browser notice the changes in dom
var initialTransitDuration = 20;

var PHASE = {
  CLOSE: 'close',
  CLOSING: 'closing',
  CLOSED: 'closed',
  OPEN: 'open',
  OPENING: 'opening',
  OPENED: 'opened'
};

var GROUP = (_GROUP = {}, _defineProperty(_GROUP, PHASE.CLOSE, PHASE.CLOSE), _defineProperty(_GROUP, PHASE.CLOSED, PHASE.CLOSE), _defineProperty(_GROUP, PHASE.OPENING, PHASE.CLOSE), _defineProperty(_GROUP, PHASE.CLOSING, PHASE.OPEN), _defineProperty(_GROUP, PHASE.OPEN, PHASE.OPEN), _defineProperty(_GROUP, PHASE.OPENED, PHASE.OPEN), _GROUP);

var Expand = function (_Component) {
  _inherits(Expand, _Component);

  function Expand() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Expand);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Expand.__proto__ || Object.getPrototypeOf(Expand)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      status: _this.props.open ? PHASE.OPEN : PHASE.CLOSE
    }, _this.getClientHeight = function () {
      return _this.refWrapper.scrollHeight;
    }, _this.getDefaultExpandStyle = function () {
      var status = _this.state.status;


      switch (status) {
        case PHASE.OPENING:
        case PHASE.CLOSE:
        case PHASE.CLOSED:
          return { height: 0, opacity: 0, overflow: 'hidden' };
        case PHASE.OPENED:
        case PHASE.CLOSING:
          return { height: _this.getClientHeight(), opacity: 1, overflow: 'hidden' };
        default:
          return { height: 'auto', opacity: 1, overflow: 'unset' };
      }
    }, _this.getExpandStyle = function () {
      return _extends({}, _this.getDefaultExpandStyle(), _this.props.styles[GROUP[_this.state.status]]);
    }, _this.getTransition = function (attribute) {
      return attribute + ' ' + _this.props.duration + 'ms ' + _this.props.easing;
    }, _this.updateStatus = function (status) {
      return _this.setState({ status: status });
    }, _this.delay = function (fn, time) {
      _this.timeout = setTimeout(fn, time);
    }, _this.clearDelay = function () {
      if (_this.timeout) {
        clearTimeout(_this.timeout);
      }
    }, _this.transit = function (entering, entered, enter) {
      var duration = _this.props.duration;


      _this.updateStatus(entering);

      _this.delay(function () {
        _this.updateStatus(entered);

        _this.delay(function () {
          _this.updateStatus(enter);
        }, duration);
      }, initialTransitDuration);
    }, _this.toggle = function (open) {
      _this.clearDelay();

      if (open) {
        _this.transit(PHASE.OPENING, PHASE.OPENED, PHASE.OPEN);
      } else {
        _this.transit(PHASE.CLOSING, PHASE.CLOSED, PHASE.CLOSE);
      }
    }, _this.setRef = function (ref) {
      _this.refWrapper = ref;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Expand, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(_ref2) {
      var open = _ref2.open;

      if (open !== this.props.open) {
        this.toggle(open);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.clearDelay();
    }
  }, {
    key: 'getStyle',
    value: function getStyle() {
      var transition = this.props.transitions.map(this.getTransition).join(',');

      return _extends({}, this.getExpandStyle(), {
        transition: transition
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          className = _props.className,
          children = _props.children,
          Tag = _props.tag;


      var childProps = {
        className: className,
        style: this.getStyle(),
        ref: this.setRef
      };

      return _react2.default.createElement(
        Tag,
        childProps,
        children
      );
    }
  }]);

  return Expand;
}(_react.Component);

Expand.propTypes = {
  children: _propTypes2.default.node.isRequired,
  open: _propTypes2.default.bool,
  duration: _propTypes2.default.number,
  easing: _propTypes2.default.string,
  className: _propTypes2.default.string,
  tag: _propTypes2.default.string,
  transitions: _propTypes2.default.arrayOf(_propTypes2.default.string),
  styles: _propTypes2.default.shape((_PropTypes$shape = {}, _defineProperty(_PropTypes$shape, PHASE.OPEN, _propTypes2.default.object), _defineProperty(_PropTypes$shape, PHASE.CLOSE, _propTypes2.default.object), _PropTypes$shape))
};

Expand.defaultProps = {
  open: false,
  duration: 400,
  easing: 'ease-in-out',
  className: '',
  tag: 'div',
  transitions: ['height', 'opacity'],
  styles: {}
};

exports.default = Expand;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9FeHBhbmQuanN4Il0sIm5hbWVzIjpbImluaXRpYWxUcmFuc2l0RHVyYXRpb24iLCJQSEFTRSIsIkNMT1NFIiwiQ0xPU0lORyIsIkNMT1NFRCIsIk9QRU4iLCJPUEVOSU5HIiwiT1BFTkVEIiwiR1JPVVAiLCJFeHBhbmQiLCJzdGF0ZSIsInN0YXR1cyIsInByb3BzIiwib3BlbiIsImdldENsaWVudEhlaWdodCIsInJlZldyYXBwZXIiLCJzY3JvbGxIZWlnaHQiLCJnZXREZWZhdWx0RXhwYW5kU3R5bGUiLCJoZWlnaHQiLCJvcGFjaXR5Iiwib3ZlcmZsb3ciLCJnZXRFeHBhbmRTdHlsZSIsInN0eWxlcyIsImdldFRyYW5zaXRpb24iLCJhdHRyaWJ1dGUiLCJkdXJhdGlvbiIsImVhc2luZyIsInVwZGF0ZVN0YXR1cyIsInNldFN0YXRlIiwiZGVsYXkiLCJmbiIsInRpbWUiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyRGVsYXkiLCJjbGVhclRpbWVvdXQiLCJ0cmFuc2l0IiwiZW50ZXJpbmciLCJlbnRlcmVkIiwiZW50ZXIiLCJ0b2dnbGUiLCJzZXRSZWYiLCJyZWYiLCJ0cmFuc2l0aW9uIiwidHJhbnNpdGlvbnMiLCJtYXAiLCJqb2luIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJUYWciLCJ0YWciLCJjaGlsZFByb3BzIiwic3R5bGUiLCJnZXRTdHlsZSIsInByb3BUeXBlcyIsIm5vZGUiLCJpc1JlcXVpcmVkIiwiYm9vbCIsIm51bWJlciIsInN0cmluZyIsImFycmF5T2YiLCJzaGFwZSIsIm9iamVjdCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBLElBQU1BLHlCQUF5QixFQUEvQjs7QUFFQSxJQUFNQyxRQUFRO0FBQ1pDLFNBQU8sT0FESztBQUVaQyxXQUFTLFNBRkc7QUFHWkMsVUFBUSxRQUhJO0FBSVpDLFFBQU0sTUFKTTtBQUtaQyxXQUFT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TUFMSjtBQU1qQlQsT0FBSyxvQkFBVVMsTUFORTtBQU9qQmYsZUFBYSxvQkFBVWdCLE9BQVYsQ0FBa0Isb0JBQVVELE1BQTVCLENBUEk7QUFRakJyQyxVQUFRLG9CQUFVdUMsS0FBViwyREFDTDVELE1BQU1JLElBREQsRUFDUSxvQkFBVXlELE1BRGxCLHFDQUVMN0QsTUFBTUMsS0FGRCxFQUVTLG9CQUFVNEQsTUFGbkI7QUFSUyxDQUFuQjs7QUFjQXJELE9BQU9zRCxZQUFQLEdBQXNCO0FBQ3BCbEQsUUFBTSxLQURjO0FBRXBCWSxZQUFVLEdBRlU7QUFHcEJDLFVBQVEsYUFIWTtBQUlwQnFCLGFBQVcsRUFKUztBQUtwQkcsT0FBSyxLQUxlO0FBTXBCTixlQUFhLENBQUMsUUFBRCxFQUFXLFNBQVgsQ0FOTztBQU9wQnRCLFVBQVE7QUFQWSxDQUF0Qjs7a0JBVWViLE0iLCJmaWxlIjoiRXhwYW5kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8vIEluIGZpcmVmb3gsIHNldFRpbWVvdXQgd2l0aCBkdXJhdGlvbiAwIHRvbyBzaG9ydCBmb3IgYnJvd3NlciBub3RpY2UgdGhlIGNoYW5nZXMgaW4gZG9tXG5jb25zdCBpbml0aWFsVHJhbnNpdER1cmF0aW9uID0gMjA7XG5cbmNvbnN0IFBIQVNFID0ge1xuICBDTE9TRTogJ2Nsb3NlJyxcbiAgQ0xPU0lORzogJ2Nsb3NpbmcnLFxuICBDTE9TRUQ6ICdjbG9zZWQnLFxuICBPUEVOOiAnb3BlbicsXG4gIE9QRU5JTkc6ICdvcGVuaW5nJyxcbiAgT1BFTkVEOiAnb3BlbmVkJyxcbn07XG5cbmNvbnN0IEdST1VQID0ge1xuICBbUEhBU0UuQ0xPU0VdOiBQSEFTRS5DTE9TRSxcbiAgW1BIQVNFLkNMT1NFRF06IFBIQVNFLkNMT1NFLFxuICBbUEhBU0UuT1BFTklOR106IFBIQVNFLkNMT1NFLFxuXG4gIFtQSEFTRS5DTE9TSU5HXTogUEhBU0UuT1BFTixcbiAgW1BIQVNFLk9QRU5dOiBQSEFTRS5PUEVOLFxuICBbUEhBU0UuT1BFTkVEXTogUEhBU0UuT1BFTixcbn07XG5cbmNsYXNzIEV4cGFuZCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRlID0ge1xuICAgIHN0YXR1czogdGhpcy5wcm9wcy5vcGVuID8gUEhBU0UuT1BFTiA6IFBIQVNFLkNMT1NFLFxuICB9O1xuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoeyBvcGVuIH0pIHtcbiAgICBpZiAob3BlbiAhPT0gdGhpcy5wcm9wcy5vcGVuKSB7XG4gICAgICB0aGlzLnRvZ2dsZShvcGVuKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNsZWFyRGVsYXkoKTtcbiAgfVxuXG4gIGdldENsaWVudEhlaWdodCA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5yZWZXcmFwcGVyLnNjcm9sbEhlaWdodDtcbiAgfTtcblxuICBnZXREZWZhdWx0RXhwYW5kU3R5bGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBQSEFTRS5PUEVOSU5HOlxuICAgICAgY2FzZSBQSEFTRS5DTE9TRTpcbiAgICAgIGNhc2UgUEhBU0UuQ0xPU0VEOlxuICAgICAgICByZXR1cm4geyBoZWlnaHQ6IDAsIG9wYWNpdHk6IDAsIG92ZXJmbG93OiAnaGlkZGVuJyB9O1xuICAgICAgY2FzZSBQSEFTRS5PUEVORUQ6XG4gICAgICBjYXNlIFBIQVNFLkNMT1NJTkc6XG4gICAgICAgIHJldHVybiB7IGhlaWdodDogdGhpcy5nZXRDbGllbnRIZWlnaHQoKSwgb3BhY2l0eTogMSwgb3ZlcmZsb3c6ICdoaWRkZW4nIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geyBoZWlnaHQ6ICdhdXRvJywgb3BhY2l0eTogMSwgb3ZlcmZsb3c6ICd1bnNldCcgfTtcbiAgICB9XG4gIH07XG5cbiAgZ2V0RXhwYW5kU3R5bGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuZ2V0RGVmYXVsdEV4cGFuZFN0eWxlKCksXG4gICAgICAuLi50aGlzLnByb3BzLnN0eWxlc1tHUk9VUFt0aGlzLnN0YXRlLnN0YXR1c11dLFxuICAgIH1cbiAgfTtcblxuICBnZXRUcmFuc2l0aW9uID0gKGF0dHJpYnV0ZSkgPT4gYCR7YXR0cmlidXRlfSAke3RoaXMucHJvcHMuZHVyYXRpb259bXMgJHt0aGlzLnByb3BzLmVhc2luZ31gO1xuXG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLnByb3BzLnRyYW5zaXRpb25zLm1hcCh0aGlzLmdldFRyYW5zaXRpb24pLmpvaW4oJywnKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmdldEV4cGFuZFN0eWxlKCksXG4gICAgICB0cmFuc2l0aW9uLFxuICAgIH07XG4gIH1cblxuICB1cGRhdGVTdGF0dXMgPSBzdGF0dXMgPT4gdGhpcy5zZXRTdGF0ZSh7IHN0YXR1cyB9KTtcblxuICBkZWxheSA9IChmbiwgdGltZSkgPT4ge1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZm4sIHRpbWUpO1xuICB9O1xuXG4gIGNsZWFyRGVsYXkgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIHRyYW5zaXQgPSAoZW50ZXJpbmcsIGVudGVyZWQsIGVudGVyKSA9PiB7XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMudXBkYXRlU3RhdHVzKGVudGVyaW5nKTtcblxuICAgIHRoaXMuZGVsYXkoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVTdGF0dXMoZW50ZXJlZCk7XG5cbiAgICAgIHRoaXMuZGVsYXkoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cyhlbnRlcik7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgfSwgaW5pdGlhbFRyYW5zaXREdXJhdGlvbik7XG4gIH07XG5cbiAgdG9nZ2xlID0gKG9wZW4pID0+IHtcbiAgICB0aGlzLmNsZWFyRGVsYXkoKTtcblxuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLnRyYW5zaXQoUEhBU0UuT1BFTklORywgUEhBU0UuT1BFTkVELCBQSEFTRS5PUEVOKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2l0KFBIQVNFLkNMT1NJTkcsIFBIQVNFLkNMT1NFRCwgUEhBU0UuQ0xPU0UpO1xuICAgIH1cbiAgfTtcblxuICBzZXRSZWYgPSAocmVmKSA9PiB7IHRoaXMucmVmV3JhcHBlciA9IHJlZjsgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGNoaWxkcmVuLCB0YWc6IFRhZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZTogdGhpcy5nZXRTdHlsZSgpLFxuICAgICAgcmVmOiB0aGlzLnNldFJlZixcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxUYWcgey4uLmNoaWxkUHJvcHN9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1RhZz5cbiAgICApO1xuICB9XG59XG5cbkV4cGFuZC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgZHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIGVhc2luZzogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0YWc6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRyYW5zaXRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgc3R5bGVzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIFtQSEFTRS5PUEVOXTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBbUEhBU0UuQ0xPU0VdOiBQcm9wVHlwZXMub2JqZWN0LFxuICB9KSxcbn07XG5cbkV4cGFuZC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9wZW46IGZhbHNlLFxuICBkdXJhdGlvbjogNDAwLFxuICBlYXNpbmc6ICdlYXNlLWluLW91dCcsXG4gIGNsYXNzTmFtZTogJycsXG4gIHRhZzogJ2RpdicsXG4gIHRyYW5zaXRpb25zOiBbJ2hlaWdodCcsICdvcGFjaXR5J10sXG4gIHN0eWxlczoge30sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHBhbmQ7XG4iXX0=